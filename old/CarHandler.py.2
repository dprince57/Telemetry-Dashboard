import yaml
from dataclasses import dataclass, field
from pathlib import Path
import TrackHandler
import math
import time
import requests
import json
from typing import Optional

G = 9.81

# Physics constants
buffer_m = 5
rho_default = 1.225

# Racing constants
DRAFT_DISTANCE_M = 15.0
DRAFT_REDUCTION = 0.15
OVERTAKE_DISTANCE_M = 30.0
SAFE_FOLLOW_DISTANCE_M = 8.0
TRACK_WIDTH_M = 12.0

# Pit stop constants
PIT_LANE_SPEED_LIMIT = 13.9
TIRE_CHANGE_TIME = 3.0
REFUEL_RATE_KG_PER_SEC = 12.0

# Network configuration
PIT_WALL_HOST = "192.168.0.212"  # Pit wall server
PIT_WALL_PORT = 5000
TELEMETRY_SEND_INTERVAL = 0.5  # Send telemetry every 0.5 seconds


@dataclass
class TireState:
    temp_C: float = 70.0
    wear: float = 0.0

@dataclass
class CarSpec:
    fuel_onboard_kg: float
    car_weight_kg: float
    tire_file: str
    aero_file: str
    engine_file: str
    brake_file: str
    fuel_capacity_kg: float = 100.0

@dataclass
class GForces:
    """G-force components experienced by driver."""
    longitudinal: float = 0.0
    lateral: float = 0.0
    vertical: float = 1.0
    total: float = 1.0

@dataclass
class PitCommand:
    """Pit command received from pit wall."""
    should_pit: bool = False
    change_tires: bool = True
    refuel_amount_kg: float = 0.0
    pit_in_progress: bool = False
    pit_timer: float = 0.0
    pit_total_time: float = 0.0

@dataclass
class CarState:
    car_id: str
    carSpec: CarSpec
    velocity_mps: float = 0.0
    track_position: float = 0.0
    acceleration_mps: float = 19.6
    laps: int = 0
    lap_start_time: float = 0.0
    best_lap: float = 0.0
    braking_zone: float = -1.0
    braking_meter: float = 0.0
    velo_target: float = 0.0
    tire_FL: TireState = field(default_factory=TireState)
    tire_FR: TireState = field(default_factory=TireState)
    tire_RL: TireState = field(default_factory=TireState)
    tire_RR: TireState = field(default_factory=TireState)
    brake_FL_C: float = 200.0
    brake_FR_C: float = 200.0
    brake_RL_C: float = 200.0
    brake_RR_C: float = 200.0
    tire_params: dict | None = None
    aero_params: dict | None = None
    engine_params: dict | None = None
    brake_params: dict | None = None
    mu_effective: float = 1.3
    throttle: float = 0.0
    brake: float = 0.0
    rpm: float = 1200.0
    gear: int = 1
    shift_timer: float = 0.0
    active_corner_start: float = -2.0
    active_corner_apex: float = -2.0
    active_corner_exit: float = -2.0
    past_apex: bool = False
    
    # Racing
    lateral_offset: float = 0.0
    overtake_side: str = "none"
    overtake_target_id: str = ""
    overtake_progress: float = 0.0
    is_drafting: bool = False
    car_ahead_id: str = ""
    car_ahead_distance: float = 999.0
    aggression: float = 0.7

    # Player control
    is_player: bool = False
    pit_speed_zone: bool = False

    # G-forces
    gforces: GForces = field(default_factory=GForces)
    prev_velocity_mps: float = 0.0
    
    # Pit stops
    pit_command: PitCommand = field(default_factory=PitCommand)
    in_pit_lane: bool = False
    pit_stops_completed: int = 0
    total_pit_time: float = 0.0
    
    # Fuel
    fuel_consumption_rate: float = 0.08
    
    # Network
    last_telemetry_send: float = 0.0


def init_car(car_id: int, spec_path: str, aggression: float = 0.7, is_player: bool = False) -> CarState:
    """Initialize car with spec file and driver aggression level."""
    with open(spec_path, "r") as f:
        raw_spec = yaml.safe_load(f)
    spec = CarSpec(**raw_spec)

    car = CarState(car_id=str(car_id), carSpec=spec, aggression=aggression, is_player=is_player)
    with open(spec.tire_file, "r") as tf:
        car.tire_params = yaml.safe_load(tf)
    with open(spec.aero_file, "r") as af:
        car.aero_params = yaml.safe_load(af)
    with open(spec.engine_file, "r") as ef:
        car.engine_params = yaml.safe_load(ef)
    with open(spec.brake_file, "r") as bf:
        car.brake_params = yaml.safe_load(bf)

    return car


# ============= Network Communication =============

def send_telemetry_to_pit_wall(car: CarState, sim_t: float) -> None:
    """Send telemetry data to pit wall server."""
    if sim_t - car.last_telemetry_send < TELEMETRY_SEND_INTERVAL:
        return
    
    avg_tire_wear = (car.tire_FL.wear + car.tire_FR.wear + 
                     car.tire_RL.wear + car.tire_RR.wear) / 4.0
    
    telemetry = {
        "car_id": car.car_id,
        "laps": car.laps,
        "position": car.track_position,
        "velocity_mps": car.velocity_mps,
        "fuel_kg": car.carSpec.fuel_onboard_kg,
        "avg_tire_wear": avg_tire_wear,
        "tire_temps": {
            "FL": car.tire_FL.temp_C,
            "FR": car.tire_FR.temp_C,
            "RL": car.tire_RL.temp_C,
            "RR": car.tire_RR.temp_C,
        },
        "tire_wear": {
            "FL": car.tire_FL.wear,
            "FR": car.tire_FR.wear,
            "RL": car.tire_RL.wear,
            "RR": car.tire_RR.wear,
        },
        "g_forces": {
            "longitudinal": car.gforces.longitudinal,
            "lateral": car.gforces.lateral,
            "vertical": car.gforces.vertical,
            "total": car.gforces.total,
        },
        "in_pit": car.in_pit_lane,
        "pit_stops": car.pit_stops_completed,
        "is_drafting": car.is_drafting,
        "sim_time": sim_t,
    }
    
    try:
        url = f"http://{PIT_WALL_HOST}:{PIT_WALL_PORT}/telemetry"
        requests.post(url, json=telemetry, timeout=0.1)
        car.last_telemetry_send = sim_t
    except Exception as e:
        # Silent fail - don't disrupt simulation
        pass


def check_pit_command_from_wall(car: CarState) -> None:
    """Check pit wall for commands for this car."""
    try:
        url = f"http://{PIT_WALL_HOST}:{PIT_WALL_PORT}/pit_command/{car.car_id}"
        response = requests.get(url, timeout=0.1)
        
        if response.status_code == 200:
            data = response.json()
            if data.get("should_pit", False):
                car.pit_command.should_pit = True
                car.pit_command.change_tires = data.get("change_tires", True)
                car.pit_command.refuel_amount_kg = data.get("refuel_amount_kg", 0.0)
                
                print(f"[PIT] Car {car.car_id} received pit command from wall")
    except Exception as e:
        # Silent fail
        pass


# ============= Pit Stop Execution =============

def _wrap_dist(a: float, b: float, lap: float) -> float:
    """Shortest distance on a circular lap."""
    a %= lap
    b %= lap
    d = abs(a - b)
    return min(d, lap - d)

def _execute_pit_stop(car: CarState, dt: float, track: TrackHandler.Track) -> None:
    """
    DRIVE-THROUGH PIT ONLY:
    - If should_pit: enter pit-speed zone at pit_entry, obey pit speed, exit at pit_exit.
    - NO stopping, NO tire change, NO refuel, NO timers.
    """
    lap = float(track.lap_length_meter)

    pit_entry = float(getattr(track, "pit_entry_position", 0.0))
    pit_exit  = float(getattr(track, "pit_exit_position", 0.0))

    # 1) Enter pit-speed zone when commanded and near entry
    if car.pit_command.should_pit and not car.in_pit_lane:
        if _wrap_dist(car.track_position, pit_entry, lap) < 50.0:
            car.in_pit_lane = True
            car.pit_command.pit_in_progress = True
            # Optional: print once
            # print(f"[PIT] Car {car.car_id} entering pit-speed zone")

    # 2) While in pit lane: cap speed (never stop)
    if car.in_pit_lane:
        if car.velocity_mps > PIT_LANE_SPEED_LIMIT:
            car.velocity_mps = PIT_LANE_SPEED_LIMIT

        # 3) Exit when near pit_exit (wrap-safe)
        if _wrap_dist(car.track_position, pit_exit, lap) < 15.0:
            car.in_pit_lane = False

            # Clear the command and any “service” behavior
            car.pit_command.should_pit = False
            car.pit_command.pit_in_progress = False
            car.pit_command.pit_timer = 0.0
            car.pit_command.pit_total_time = 0.0

            # Optional: print once
            # print(f"[PIT] Car {car.car_id} exiting pit-speed zone")


def _calculate_fuel_consumption(car: CarState, dt: float) -> None:
    """Calculate and apply fuel consumption."""
    if car.carSpec.fuel_onboard_kg <= 0:
        car.throttle = 0.0
        return
    
    consumption = car.fuel_consumption_rate * car.throttle * dt
    car.carSpec.fuel_onboard_kg = max(0.0, car.carSpec.fuel_onboard_kg - consumption)


# ============= G-Force Calculation =============

def _calculate_gforces(car: CarState, dt: float, track: TrackHandler.Track) -> None:
    """Calculate G-forces experienced by the driver."""
    
    delta_v = car.velocity_mps - car.prev_velocity_mps
    accel_mps2 = delta_v / max(dt, 0.001)
    g_longitudinal = accel_mps2 / G
    
    current_segment = None
    for seg in track.segments:
        if seg.type == "corner":
            start_s, apex_s, end_s = _get_corner_boundaries(seg)
            if start_s <= car.track_position <= end_s:
                current_segment = seg
                break
    
    if current_segment and current_segment.type == "corner":
        radius = current_segment.radius_meter
        v = car.velocity_mps
        lateral_accel = (v * v) / max(radius, 1.0)
        g_lateral = lateral_accel / G
    else:
        g_lateral = 0.0
    
    mass = car.carSpec.car_weight_kg + car.carSpec.fuel_onboard_kg
    F_down, _ = _calculate_aero_forces(car, car.is_drafting)
    g_vertical = 1.0 + (F_down / max(mass * G, 1.0))
    
    g_total = math.sqrt(g_longitudinal**2 + g_lateral**2 + g_vertical**2)
    
    car.gforces.longitudinal = g_longitudinal
    car.gforces.lateral = g_lateral
    car.gforces.vertical = g_vertical
    car.gforces.total = g_total
    
    car.prev_velocity_mps = car.velocity_mps


# ============= Multi-Car Racing Functions =============

def _get_relative_position(car: CarState, other: CarState, track_length: float) -> float:
    """Calculate distance from car to other car."""
    diff = other.track_position - car.track_position
    
    if diff > track_length / 2:
        diff -= track_length
    elif diff < -track_length / 2:
        diff += track_length
    
    return diff


def _find_car_ahead(car: CarState, all_cars: list[CarState], track: TrackHandler.Track) -> tuple[CarState | None, float]:
    """Find the nearest car ahead on track."""
    
    closest_ahead = None
    min_distance = 999.0
    
    for other in all_cars:
        if other.car_id == car.car_id:
            continue
        
        rel_pos = _get_relative_position(car, other, track.lap_length_meter)
        
        if 0 < rel_pos < min_distance:
            lateral_diff = abs(car.lateral_offset - other.lateral_offset)
            if lateral_diff < 0.5:
                min_distance = rel_pos
                closest_ahead = other
    
    return closest_ahead, min_distance


def _is_drafting(car: CarState, car_ahead: CarState, distance: float) -> bool:
    """Check if car is in draft zone."""
    if distance > DRAFT_DISTANCE_M:
        return False
    
    lateral_diff = abs(car.lateral_offset - car_ahead.lateral_offset)
    return lateral_diff < 0.3


def _can_overtake(car: CarState, car_ahead: CarState, distance: float, 
                  track: TrackHandler.Track) -> tuple[bool, str]:
    """Determine if overtaking is possible."""
    
    if distance > OVERTAKE_DISTANCE_M or distance < 2.0:
        return False, "none"
    
    speed_advantage = car.velocity_mps - car_ahead.velocity_mps
    if speed_advantage < 2.0:
        return False, "none"
    
    in_corner = abs(car.track_position - car.active_corner_apex) < 20.0
    if in_corner and car.aggression < 0.8:
        return False, "none"
    
    if in_corner:
        side = "left" if car_ahead.lateral_offset > 0 else "right"
    else:
        side = "left" if car_ahead.lateral_offset > -0.3 else "right"
    
    return True, side


def _update_overtake_maneuver(car: CarState, dt: float) -> None:
    """Update overtake maneuver progress."""
    
    if car.overtake_side == "none":
        return_rate = 0.5 * dt
        if abs(car.lateral_offset) > 0.01:
            if car.lateral_offset > 0:
                car.lateral_offset = max(0.0, car.lateral_offset - return_rate)
            else:
                car.lateral_offset = min(0.0, car.lateral_offset + return_rate)
        return
    
    overtake_duration = 3.0
    lateral_speed = 1.0 / overtake_duration
    target_offset = 0.7 if car.overtake_side == "right" else -0.7
    
    if car.overtake_side == "right":
        car.lateral_offset = min(target_offset, car.lateral_offset + lateral_speed * dt)
    else:
        car.lateral_offset = max(target_offset, car.lateral_offset - lateral_speed * dt)
    
    car.overtake_progress += dt / overtake_duration
    
    if car.overtake_progress >= 1.0:
        car.overtake_side = "none"
        car.overtake_target_id = ""
        car.overtake_progress = 0.0


def _calculate_traffic_speed_limit(car: CarState, car_ahead: CarState, 
                                    distance: float, aggression: float) -> float:
    """Calculate safe speed based on traffic."""
    
    if distance > OVERTAKE_DISTANCE_M:
        return 999.0
    
    safe_distance = SAFE_FOLLOW_DISTANCE_M + car.velocity_mps * 0.3
    safe_distance *= (1.5 - aggression * 0.5)
    
    if distance < safe_distance:
        return car_ahead.velocity_mps * 0.95
    elif distance < safe_distance * 1.5:
        return car_ahead.velocity_mps * 1.05
    else:
        return 999.0


# ============= Helper Functions =============

def _find_next_corner(car: CarState, track: TrackHandler.Track) -> bool:
    """Find next corner."""
    
    for seg in track.segments:
        if seg.type == "corner" and seg.s_meter > car.track_position:
            car.braking_zone = seg.s_meter
            car.velo_target = math.sqrt(max(0.0, car.mu_effective * G * seg.radius_meter))
            return True
    
    for seg in track.segments:
        if seg.type == "corner":
            car.braking_zone = seg.s_meter
            car.velo_target = math.sqrt(max(0.0, car.mu_effective * G * seg.radius_meter))
            return True
    
    return False


def _get_corner_boundaries(seg: TrackHandler.Segment, default_corner_length: float = 60.0) -> tuple:
    """Extract corner boundaries."""
    
    start_s = seg.s_meter
    seg_len = getattr(seg, "length_meter", None)
    end_s = getattr(seg, "end_s_meter", None)
    apex_s = getattr(seg, "apex_s_meter", None)

    if end_s is None:
        end_s = start_s + (float(seg_len) if seg_len is not None else default_corner_length)

    if apex_s is None:
        apex_s = start_s + 0.5 * (end_s - start_s)

    return start_s, apex_s, end_s


def _update_active_corner(car: CarState, track: TrackHandler.Track) -> bool:
    """Update active corner tracking."""
    
    need_new_corner = (car.active_corner_exit < 0) or (car.track_position >= car.active_corner_exit)
    
    if not need_new_corner:
        return False

    for seg in track.segments:
        if seg.type == "corner" and seg.s_meter > car.track_position:
            start_s, apex_s, end_s = _get_corner_boundaries(seg)
            car.active_corner_start = start_s
            car.active_corner_apex = apex_s
            car.active_corner_exit = end_s
            car.past_apex = False
            car.velo_target = math.sqrt(max(0.0, car.mu_effective * G * seg.radius_meter))
            return True

    for seg in track.segments:
        if seg.type == "corner":
            start_s, apex_s, end_s = _get_corner_boundaries(seg)
            car.active_corner_start = start_s
            car.active_corner_apex = apex_s
            car.active_corner_exit = end_s
            car.past_apex = False
            car.velo_target = math.sqrt(max(0.0, car.mu_effective * G * seg.radius_meter))
            return True

    return False


def _calculate_aero_forces(car: CarState, is_drafting: bool = False) -> tuple:
    """Calculate downforce and drag."""
    
    rho = rho_default
    ClA = 0.0
    CdA = 0.0
    
    if car.aero_params is not None:
        rho = float(car.aero_params.get("rho", rho_default))
        ClA = float(car.aero_params.get("ClA", 0.0))
        CdA = float(car.aero_params.get("CdA", 0.0))

    v = car.velocity_mps
    drag_multiplier = (1.0 - DRAFT_REDUCTION) if is_drafting else 1.0
    
    F_down = 0.5 * rho * ClA * v * v
    F_drag = 0.5 * rho * CdA * v * v * drag_multiplier
    
    return F_down, F_drag


def _calculate_tire_friction(car: CarState, mass: float, F_down: float) -> None:
    """Calculate tire friction."""
    
    tp = car.tire_params
    
    if tp is None:
        car.mu_effective = 1.30
        return

    mu_peak_ref = float(tp["mu_peak_ref"])
    Fz_ref_N = float(tp["Fz_ref_N"])
    k_mu = float(tp["load_sensitivity"]["k_mu"])

    optC = float(tp["temperature"]["optimal_C"])
    coldC = float(tp["temperature"]["cold_C"])
    hotC = float(tp["temperature"]["hot_C"])
    drop_cold = float(tp["temperature"]["grip_drop_cold"])
    drop_hot = float(tp["temperature"]["grip_drop_hot"])

    mu_drop_wear = float(tp["wear"]["mu_drop_at_full_wear"])
    Fz_total = mass * G + F_down
    Fz_tire = Fz_total / 4.0

    load_ratio = max(0.1, Fz_tire / max(1e-6, Fz_ref_N))
    mu_load = mu_peak_ref * (1.0 - k_mu * math.log(load_ratio))

    mu_list = []
    for tire in [car.tire_FL, car.tire_FR, car.tire_RL, car.tire_RR]:
        T = tire.temp_C
        
        if T <= coldC:
            f_temp = 1.0 - drop_cold
        elif T >= hotC:
            f_temp = 1.0 - drop_hot
        else:
            if T <= optC:
                f_temp = (1.0 - drop_cold) + (T - coldC) * (drop_cold / max(1e-6, (optC - coldC)))
            else:
                f_temp = (1.0 - drop_hot) + (hotC - T) * (drop_hot / max(1e-6, (hotC - optC)))
            f_temp = max(0.2, min(1.0, f_temp))

        w = max(0.0, min(1.0, tire.wear))
        f_wear = 1.0 - (mu_drop_wear * w)

        mu_list.append(max(0.2, mu_load * f_temp * f_wear))

    car.mu_effective = sum(mu_list) / len(mu_list)


def _calculate_brake_fade(car: CarState) -> tuple:
    """Calculate brake fade."""
    
    a_brake_base = 10.0
    fade_start = 650.0
    fade_end = 950.0
    fade_min = 0.70
    
    if car.brake_params is not None:
        a_brake_base = float(car.brake_params.get("a_brake_base", a_brake_base))
        fade_start = float(car.brake_params.get("fade_start_C", fade_start))
        fade_end = float(car.brake_params.get("fade_end_C", fade_end))
        fade_min = float(car.brake_params.get("fade_min", fade_min))

    brake_temp_avg = (car.brake_FL_C + car.brake_FR_C + car.brake_RL_C + car.brake_RR_C) / 4.0
    
    if brake_temp_avg <= fade_start:
        brake_fade = 1.0
    elif brake_temp_avg >= fade_end:
        brake_fade = fade_min
    else:
        brake_fade = 1.0 - (brake_temp_avg - fade_start) * ((1.0 - fade_min) / max(1e-6, (fade_end - fade_start)))

    mu_ref = 1.30
    grip_scale = max(0.50, min(1.50, car.mu_effective / max(1e-6, mu_ref)))
    a_brake_eff = max(0.5, a_brake_base * grip_scale * brake_fade)

    return brake_fade, a_brake_eff, brake_temp_avg


def _get_distance_to_corner_points(car: CarState, track: TrackHandler.Track) -> tuple:
    """Calculate distances to corner points."""
    
    dist_to_apex = car.active_corner_apex - car.track_position
    if dist_to_apex < 0:
        dist_to_apex += track.lap_length_meter

    dist_to_exit = car.active_corner_exit - car.track_position
    if dist_to_exit < 0:
        dist_to_exit += track.lap_length_meter

    return dist_to_apex, dist_to_exit


def _calculate_brake_demand(car: CarState, dist_to_apex: float, a_brake_eff: float,
                            traffic_speed_limit: float) -> float:
    """Calculate brake demand."""
    
    effective_target = min(car.velo_target, traffic_speed_limit)
    
    if car.velocity_mps > effective_target and effective_target > 0:
        braking_meter = (car.velocity_mps**2 - effective_target**2) / (2.0 * max(1e-6, a_brake_eff))
    else:
        braking_meter = 0.0

    car.braking_meter = braking_meter
    full_brake_dist = braking_meter + buffer_m
    trail_braking_dist = 0.5
    
    if car.velocity_mps > traffic_speed_limit:
        return 1.0
    
    if car.velocity_mps <= effective_target:
        return 0.0
    
    if not car.past_apex and dist_to_apex <= full_brake_dist:
        if dist_to_apex <= trail_braking_dist:
            brake_demand = max(0.0, dist_to_apex / trail_braking_dist)
        else:
            brake_demand = 1.0
        return brake_demand
    
    return 0.0


def _calculate_throttle_demand(car: CarState, dist_to_apex: float, a_brake_eff: float,
                               traffic_speed_limit: float) -> float:
    """Calculate throttle demand."""
    
    effective_target = min(car.velo_target, traffic_speed_limit)
    
    if car.velocity_mps > effective_target and effective_target > 0:
        braking_meter = (car.velocity_mps**2 - effective_target**2) / (2.0 * max(1e-6, a_brake_eff))
    else:
        braking_meter = 0.0

    full_brake_dist = braking_meter + buffer_m
    exit_ramp_dist = 5.0
    
    if car.velocity_mps >= traffic_speed_limit * 0.95:
        return 0.2
    
    if car.past_apex:
        throttle = min(1.0, 1.0 - (dist_to_apex / exit_ramp_dist))
        return max(0.0, throttle)
    else:
        if dist_to_apex <= full_brake_dist:
            return 0.0
        else:
            return 1.0


def _update_throttle_and_brake(car: CarState, dist_to_apex: float, a_brake_eff: float,
                               traffic_speed_limit: float) -> None:
    """Update throttle and brake."""
    
    if car.pit_command.pit_timer > 0:
        car.throttle = 0.0
        car.brake = 1.0
        car.velocity_mps = 0.0
        return
    
    if car.in_pit_lane:
        if car.velocity_mps > PIT_LANE_SPEED_LIMIT:
            car.throttle = 0.0
            car.brake = 0.5
            return
    
    if dist_to_apex <= 1.0:
        car.past_apex = True

    brake_demand = _calculate_brake_demand(car, dist_to_apex, a_brake_eff, traffic_speed_limit)
    throttle_demand = _calculate_throttle_demand(car, dist_to_apex, a_brake_eff, traffic_speed_limit)
    
    if brake_demand > 0.05:
        car.brake = brake_demand
        car.throttle = 0.0
    elif throttle_demand > 0.05:
        car.throttle = throttle_demand
        car.brake = 0.0
    else:
        car.brake = 0.0
        car.throttle = 0.0


def _get_engine_parameters(ep: dict) -> dict:
    """Extract engine parameters."""
    
    return {
        "idle_rpm": float(ep.get("idle_rpm", 1200.0)),
        "redline_rpm": float(ep.get("redline_rpm", 9000.0)),
        "shift_rpm": float(ep.get("shift_rpm", 8200.0)),
        "downshift_rpm": float(ep.get("downshift_rpm", 2500.0)),
        "gear_ratios": ep.get("gear_ratios", [3.20, 2.30, 1.80, 1.45, 1.20, 1.00]),
        "final_drive": float(ep.get("final_drive", 3.70)),
        "wheel_radius_m": float(ep.get("wheel_radius_m", 0.33)),
        "driveline_eff": float(ep.get("drivetrain_eff", 0.92)),
        "top_speed_cap": float(ep.get("top_speed_cap_mps", 1e9)),
        "shift_time_s": float(ep.get("shift_time_s", 0.18)),
        "torque_curve": ep.get("torque_curve", [[1000, 250], [3000, 380], [6000, 420], [8000, 390], [9000, 320]]),
    }


def _update_gear_and_rpm(car: CarState, engine_params: dict, dt: float) -> None:
    """Update gear and RPM."""
    
    idle_rpm = engine_params["idle_rpm"]
    redline_rpm = engine_params["redline_rpm"]
    shift_rpm = engine_params["shift_rpm"]
    downshift_rpm = engine_params["downshift_rpm"]
    gear_ratios = engine_params["gear_ratios"]
    final_drive = engine_params["final_drive"]
    wheel_radius_m = engine_params["wheel_radius_m"]
    shift_time = engine_params["shift_time_s"]

    max_gear = max(1, len(gear_ratios))
    car.gear = max(1, min(max_gear, car.gear))

    if car.shift_timer > 0.0:
        car.shift_timer = max(0.0, car.shift_timer - dt)

    wheel_omega = car.velocity_mps / max(1e-6, wheel_radius_m)
    gear_ratio = float(gear_ratios[car.gear - 1])
    rpm_from_speed = wheel_omega * gear_ratio * final_drive * (60.0 / (2.0 * math.pi))
    car.rpm = max(idle_rpm, rpm_from_speed)

    if car.shift_timer <= 0.0:
        if car.rpm >= shift_rpm and car.gear < max_gear and (car.throttle > 0.3 or car.rpm >= shift_rpm + 200):
            car.gear += 1
            car.shift_timer = shift_time
        elif car.rpm <= downshift_rpm and car.gear > 1 and (car.brake > 0.2 or car.throttle < 0.1):
            car.gear -= 1
            car.shift_timer = shift_time

    gear_ratio = float(gear_ratios[car.gear - 1])
    rpm_from_speed = wheel_omega * gear_ratio * final_drive * (60.0 / (2.0 * math.pi))
    car.rpm = max(idle_rpm, min(redline_rpm, rpm_from_speed))


def _calculate_torque(car: CarState, engine_params: dict) -> float:
    """Calculate engine torque."""
    
    torque_curve = engine_params["torque_curve"]
    rpm_now = car.rpm

    torque_Nm = float(torque_curve[0][1])
    if rpm_now <= float(torque_curve[0][0]):
        torque_Nm = float(torque_curve[0][1])
    elif rpm_now >= float(torque_curve[-1][0]):
        torque_Nm = float(torque_curve[-1][1])
    else:
        for i in range(len(torque_curve) - 1):
            r0 = float(torque_curve[i][0])
            t0 = float(torque_curve[i][1])
            r1 = float(torque_curve[i + 1][0])
            t1 = float(torque_curve[i + 1][1])
            if r0 <= rpm_now <= r1:
                alpha = (rpm_now - r0) / max(1e-6, (r1 - r0))
                torque_Nm = t0 + alpha * (t1 - t0)
                break

    torque_Nm *= max(0.0, min(1.0, car.throttle))

    if car.shift_timer > 0.0:
        torque_Nm = 0.0

    return torque_Nm


def _calculate_driving_force(car: CarState, mass: float, F_down: float, engine_params: dict) -> tuple:
    """Calculate driving force."""
    
    torque_Nm = _calculate_torque(car, engine_params)

    gear_ratios = engine_params["gear_ratios"]
    final_drive = engine_params["final_drive"]
    wheel_radius_m = engine_params["wheel_radius_m"]
    driveline_eff = engine_params["driveline_eff"]

    gear_ratio = float(gear_ratios[car.gear - 1])
    wheel_torque = torque_Nm * gear_ratio * final_drive * driveline_eff
    F_drive = wheel_torque / max(1e-6, wheel_radius_m)

    Fz_total = mass * G + F_down
    F_trac_max = car.mu_effective * Fz_total
    F_drive = max(-F_trac_max, min(F_trac_max, F_drive))

    _, a_brake_eff, _ = _calculate_brake_fade(car)
    F_brake = car.brake * a_brake_eff * mass

    Crr = 0.015
    tp = car.tire_params
    if tp is not None and "rr" in tp and "Crr" in tp["rr"]:
        Crr = float(tp["rr"]["Crr"])
    F_rr = Crr * Fz_total

    _, F_drag = _calculate_aero_forces(car, car.is_drafting)

    F_net = F_drive - F_drag - F_rr - F_brake
    a = F_net / max(1e-6, mass)
    max_accel = 2.0 * G 
    a = max(-max_accel, min(max_accel, a))

    return F_drive, F_brake, F_rr, F_drag, F_net, a


def _apply_tire_heating_and_wear(car: CarState, dt: float, ep: dict) -> None:
    """Update tire temperature and wear."""
    
    cool_rate = float(ep.get("tire_cool_rate", 0.08))
    heat_brake = float(ep.get("tire_heat_brake", 18.0))
    heat_accel = float(ep.get("tire_heat_accel", 8.0))
    wear_brake = float(ep.get("tire_wear_brake", 0.0005))
    wear_accel = float(ep.get("tire_wear_accel", 0.0002))

    ambient = 25.0

    for tire in [car.tire_FL, car.tire_FR, car.tire_RL, car.tire_RR]:
        tire.temp_C -= cool_rate * (tire.temp_C - ambient) * dt
        tire.temp_C = max(0.0, tire.temp_C)

    if car.brake > 0.1:
        brake_factor = car.brake
        car.tire_FL.temp_C += heat_brake * brake_factor * dt
        car.tire_FR.temp_C += heat_brake * brake_factor * dt
        car.tire_RL.temp_C += 0.6 * heat_brake * brake_factor * dt
        car.tire_RR.temp_C += 0.6 * heat_brake * brake_factor * dt

        car.tire_FL.wear += wear_brake * brake_factor * dt
        car.tire_FR.wear += wear_brake * brake_factor * dt
        car.tire_RL.wear += 0.6 * wear_brake * brake_factor * dt
        car.tire_RR.wear += 0.6 * wear_brake * brake_factor * dt
    
    if car.throttle > 0.1:
        throttle_factor = car.throttle
        car.tire_RL.temp_C += heat_accel * throttle_factor * dt
        car.tire_RR.temp_C += heat_accel * throttle_factor * dt
        car.tire_FL.temp_C += 0.4 * heat_accel * throttle_factor * dt
        car.tire_FR.temp_C += 0.4 * heat_accel * throttle_factor * dt

        car.tire_RL.wear += wear_accel * throttle_factor * dt
        car.tire_RR.wear += wear_accel * throttle_factor * dt
        car.tire_FL.wear += 0.4 * wear_accel * throttle_factor * dt
        car.tire_FR.wear += 0.4 * wear_accel * throttle_factor * dt

    for tire in [car.tire_FL, car.tire_FR, car.tire_RL, car.tire_RR]:
        tire.wear = max(0.0, min(1.0, tire.wear))


def _apply_brake_heating_and_cooling(car: CarState, dt: float, ep: dict) -> None:
    """Update brake temperatures."""
    
    ambient = 25.0
    brake_cool = float(ep.get("brake_cool_rate", 0.10))
    brake_heat_per_brake = float(ep.get("brake_heat_gain", 120.0))

    for attr in ["brake_FL_C", "brake_FR_C", "brake_RL_C", "brake_RR_C"]:
        cur = getattr(car, attr)
        cur -= brake_cool * (cur - ambient) * dt
        setattr(car, attr, max(ambient, cur))

    if car.brake > 0.0:
        heat = brake_heat_per_brake * car.brake * dt
        car.brake_FL_C += heat
        car.brake_FR_C += heat
        car.brake_RL_C += 0.6 * heat
        car.brake_RR_C += 0.6 * heat


def _handle_lap_completion(car: CarState, track: TrackHandler.Track, dt: float, sim_t: float, old_pos: float) -> None:
    """Handle lap completion."""
    
    if car.track_position >= track.lap_length_meter:
        minutes = sim_t / 60
        seconds = sim_t % 60
        print(f"Car {car.car_id} - Lap {car.laps + 1} | Time: {minutes:.0f}:{seconds:.2f}")
        
        distance_from_start = track.lap_length_meter - old_pos
        distance_traveled = car.track_position - old_pos
        time_frac = distance_from_start / distance_traveled if distance_traveled > 0 else 0.0
        crossing_time = (sim_t - dt) + time_frac * dt
        
        car.laps += 1
        car.best_lap = crossing_time
        car.track_position -= track.lap_length_meter



# ============= AI Pit-Speed Zone (No Real Pit Stops) =============

def _in_interval_wrap(x: float, start: float, end: float, lap: float) -> bool:
    """Return True if x is in [start, end] on a wrapping lap coordinate."""
    x %= lap
    start %= lap
    end %= lap
    if start <= end:
        return start <= x <= end
    # wraps around zero
    return x >= start or x <= end


def _apply_ai_pit_speed_zone(car: CarState, track: TrackHandler.Track) -> None:
    """
    AI never performs a real pit stop. They only obey pit-lane speed while passing
    through a pit-speed zone defined on the track (entry->exit, wrap-safe).
    They do not stop, refuel, or change tires.
    """
    pit_entry = float(getattr(track, "pit_entry_position", 0.0))
    pit_exit = float(getattr(track, "pit_exit_position", pit_entry + 300.0))
    lap = float(track.lap_length_meter)

    in_zone = _in_interval_wrap(car.track_position, pit_entry, pit_exit, lap)
    car.pit_speed_zone = in_zone
    car.in_pit_lane = in_zone  # reuse existing status flag

    if in_zone and car.velocity_mps > PIT_LANE_SPEED_LIMIT:
        car.velocity_mps = PIT_LANE_SPEED_LIMIT

    # Hard-disable pit state for AI
    car.pit_command.should_pit = False
    car.pit_command.pit_in_progress = False
    car.pit_command.pit_timer = 0.0


def run_sim(car: CarState, dt: float, track: TrackHandler.Track, sim_t: float, 
            all_cars: list[CarState] | None = None) -> dict | None:
    """Main simulation loop."""

    start_time = time.time()
    mass = car.carSpec.car_weight_kg + car.carSpec.fuel_onboard_kg


    if car.is_player:
        # Only player cars can be controlled by pit wall and do real pit stops
        check_pit_command_from_wall(car)
        _execute_pit_stop(car, dt, track)
    else:
        # AI cars never stop; they only slow through the pit-speed zone
        _apply_ai_pit_speed_zone(car, track)


    # Multi-car racing
    if all_cars is None:
        all_cars = [car]
    
    car_ahead, distance_ahead = _find_car_ahead(car, all_cars, track)
    car.is_drafting = False
    traffic_speed_limit = 999.0
    
    if car_ahead is not None:
        car.car_ahead_id = car_ahead.car_id
        car.car_ahead_distance = distance_ahead
        car.is_drafting = _is_drafting(car, car_ahead, distance_ahead)
        traffic_speed_limit = _calculate_traffic_speed_limit(car, car_ahead, distance_ahead, car.aggression)
        
        if car.overtake_side == "none":
            can_overtake, side = _can_overtake(car, car_ahead, distance_ahead, track)
            if can_overtake:
                car.overtake_side = side
                car.overtake_target_id = car_ahead.car_id
                car.overtake_progress = 0.0
    else:
        car.car_ahead_id = ""
        car.car_ahead_distance = 999.0
    
    _update_overtake_maneuver(car, dt)

    # Physics
    if car.track_position >= car.braking_zone:
        _find_next_corner(car, track)

    old_pos = car.track_position
    old_v = car.velocity_mps

    F_down, F_drag = _calculate_aero_forces(car, car.is_drafting)
    _calculate_tire_friction(car, mass, F_down)
    brake_fade, a_brake_eff, brake_temp_avg = _calculate_brake_fade(car)
    _update_active_corner(car, track)
    dist_to_apex, dist_to_exit = _get_distance_to_corner_points(car, track)
    
    _update_throttle_and_brake(car, dist_to_apex, a_brake_eff, traffic_speed_limit)
    
    engine_params = _get_engine_parameters(car.engine_params or {})
    _update_gear_and_rpm(car, engine_params, dt)
    F_drive, F_brake, F_rr, F_drag_unused, F_net, a = _calculate_driving_force(car, mass, F_down, engine_params)

    top_speed_cap = engine_params["top_speed_cap"]
    car.velocity_mps = max(0.0, min(top_speed_cap, car.velocity_mps + a * dt))
    car.track_position += ((old_v + car.velocity_mps) / 2.0) * dt

    # G-forces
    _calculate_gforces(car, dt, track)
    
    # Fuel
    _calculate_fuel_consumption(car, dt)

    _apply_brake_heating_and_cooling(car, dt, car.engine_params or {})
    _apply_tire_heating_and_wear(car, dt, car.engine_params or {})
    _handle_lap_completion(car, track, dt, sim_t, old_pos)

    # Send telemetry to pit wall
    send_telemetry_to_pit_wall(car, sim_t)

    # Debug output
    print(
        f"Car {car.car_id} | Speed: {car.velocity_mps:.1f} m/s | "
        f"G:{car.gforces.total:.1f} | Fuel: {car.carSpec.fuel_onboard_kg:.1f}kg"
    )

    end_time = time.time()

    return {
        "t": sim_t,
        "car_id": car.car_id,
        "v_mps": car.velocity_mps,
        "x_m": car.track_position,
        "laps": car.laps,
        "fuel_kg": car.carSpec.fuel_onboard_kg,
        "g_total": car.gforces.total,
    }

